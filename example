package main

import (
	"crypto/tls"
	"flag"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"sync"
	"time"

	"github.com/gen2brain/beeep"
	"gopkg.in/yaml.v3"
)

// Ð¡Ñ‚Ñ€ÑƒÐºÑ‚ÑƒÑ€Ñ‹ Ð´Ð»Ñ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸
type Config struct {
	Sites          []SiteConfig `yaml:"sites"`
	Notifications  Notifications `yaml:"notifications"`
	General        GeneralConfig `yaml:"general"`
}

type SiteConfig struct {
	URL     string `yaml:"url"`
	Name    string `yaml:"name"`
	Timeout int    `yaml:"timeout"`
}

type Notifications struct {
	ShowPopup    bool `yaml:"show_popup"`
	ConsoleOutput bool `yaml:"console_output"`
}

type GeneralConfig struct {
	CheckInterval   int `yaml:"check_interval"`
	ConcurrentChecks int `yaml:"concurrent_checks"`
}

// Ð ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸
type CheckResult struct {
	Site      SiteConfig
	Success   bool
	StatusCode int
	Error     string
	Duration  time.Duration
}

func main() {
	// ÐŸÐ°Ñ€ÑÐ¸Ð½Ð³ Ð°Ñ€Ð³ÑƒÐ¼ÐµÐ½Ñ‚Ð¾Ð² ÐºÐ¾Ð¼Ð°Ð½Ð´Ð½Ð¾Ð¹ ÑÑ‚Ñ€Ð¾ÐºÐ¸
	configFile := flag.String("config", "config.yaml", "ÐŸÑƒÑ‚ÑŒ Ðº Ñ„Ð°Ð¹Ð»Ñƒ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸")
	once := flag.Bool("once", false, "Ð’Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ñ‚ÑŒ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¾Ð´Ð½Ñƒ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÑƒ Ð¸ Ð²Ñ‹Ð¹Ñ‚Ð¸")
	verbose := flag.Bool("v", false, "ÐŸÐ¾Ð´Ñ€Ð¾Ð±Ð½Ñ‹Ð¹ Ð²Ñ‹Ð²Ð¾Ð´")
	flag.Parse()

	// Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸
	config, err := loadConfig(*configFile)
	if err != nil {
		fmt.Printf("ÐžÑˆÐ¸Ð±ÐºÐ° Ð·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ¸ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸: %v\n", err)
		os.Exit(1)
	}

	fmt.Printf("Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾ %d ÑÐ°Ð¹Ñ‚Ð¾Ð² Ð´Ð»Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸\n", len(config.Sites))
	fmt.Printf("Ð˜Ð½Ñ‚ÐµÑ€Ð²Ð°Ð» Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸: %d ÑÐµÐºÑƒÐ½Ð´\n", config.General.CheckInterval)

	// Ð•ÑÐ»Ð¸ ÑƒÐºÐ°Ð·Ð°Ð½ Ñ„Ð»Ð°Ð³ -once Ð¸Ð»Ð¸ Ð¸Ð½Ñ‚ÐµÑ€Ð²Ð°Ð» 0, Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ Ð¾Ð´Ð½Ñƒ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÑƒ
	if *once || config.General.CheckInterval == 0 {
		results := checkAllSites(config, *verbose)
		printResults(results, config.Notifications)
		
		if allSitesOK(results) {
			sendSuccessNotification(config)
			os.Exit(0)
		} else {
			os.Exit(1)
		}
	}

	// Ð—Ð°Ð¿ÑƒÑÐº Ð¿ÐµÑ€Ð¸Ð¾Ð´Ð¸Ñ‡ÐµÑÐºÐ¾Ð¹ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸
	runContinuousMonitoring(config, *verbose)
}

// Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸ Ð¸Ð· YAML
func loadConfig(filename string) (*Config, error) {
	data, err := os.ReadFile(filename)
	if err != nil {
		// Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð¿Ñ€Ð¸Ð¼ÐµÑ€ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸, ÐµÑÐ»Ð¸ Ñ„Ð°Ð¹Ð» Ð½Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚
		if os.IsNotExist(err) {
			return createDefaultConfig(filename)
		}
		return nil, err
	}

	var config Config
	err = yaml.Unmarshal(data, &config)
	if err != nil {
		return nil, err
	}

	// Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ñ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ
	if config.General.ConcurrentChecks == 0 {
		config.General.ConcurrentChecks = 3
	}
	if config.General.CheckInterval == 0 {
		config.General.CheckInterval = 60
	}

	return &config, nil
}

// Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ
func createDefaultConfig(filename string) (*Config, error) {
	defaultConfig := Config{
		Sites: []SiteConfig{
			{URL: "https://google.com", Name: "Google", Timeout: 10},
			{URL: "https://github.com", Name: "GitHub", Timeout: 5},
		},
		Notifications: Notifications{
			ShowPopup:    true,
			ConsoleOutput: true,
		},
		General: GeneralConfig{
			CheckInterval:   60,
			ConcurrentChecks: 3,
		},
	}

	data, err := yaml.Marshal(&defaultConfig)
	if err != nil {
		return nil, err
	}

	err = os.WriteFile(filename, data, 0644)
	if err != nil {
		return nil, err
	}

	fmt.Printf("Ð¡Ð¾Ð·Ð´Ð°Ð½ Ñ„Ð°Ð¹Ð» ÐºÐ¾Ð½Ñ„Ð¸Ð³ÑƒÑ€Ð°Ñ†Ð¸Ð¸: %s\n", filename)
	return &defaultConfig, nil
}

// ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð¾Ð´Ð½Ð¾Ð³Ð¾ ÑÐ°Ð¹Ñ‚Ð°
func checkSite(site SiteConfig, verbose bool) CheckResult {
	start := time.Now()
	
	// Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ HTTP ÐºÐ»Ð¸ÐµÐ½Ñ‚ Ñ Ñ‚Ð°Ð¹Ð¼Ð°ÑƒÑ‚Ð¾Ð¼
	client := &http.Client{
		Timeout: time.Duration(site.Timeout) * time.Second,
		Transport: &http.Transport{
			TLSClientConfig: &tls.Config{InsecureSkipVerify: false},
		},
	}

	// Ð¡Ð¾Ð·Ð´Ð°ÐµÐ¼ Ð·Ð°Ð¿Ñ€Ð¾Ñ
	req, err := http.NewRequest("GET", site.URL, nil)
	if err != nil {
		return CheckResult{
			Site:     site,
			Success:  false,
			Error:    fmt.Sprintf("ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ñ Ð·Ð°Ð¿Ñ€Ð¾ÑÐ°: %v", err),
			Duration: time.Since(start),
		}
	}

	// Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÐ¼ User-Agent
	req.Header.Set("User-Agent", "WebsiteChecker/1.0")

	// Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÐ¼ Ð·Ð°Ð¿Ñ€Ð¾Ñ
	resp, err := client.Do(req)
	if err != nil {
		return CheckResult{
			Site:     site,
			Success:  false,
			Error:    fmt.Sprintf("ÐžÑˆÐ¸Ð±ÐºÐ° ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ñ: %v", err),
			Duration: time.Since(start),
		}
	}
	defer resp.Body.Close()

	// Ð§Ð¸Ñ‚Ð°ÐµÐ¼ Ð½ÐµÐ¼Ð½Ð¾Ð³Ð¾ Ñ‚ÐµÐ»Ð° Ð¾Ñ‚Ð²ÐµÑ‚Ð° (Ñ‡Ñ‚Ð¾Ð±Ñ‹ ÑƒÐ±ÐµÐ´Ð¸Ñ‚ÑŒÑÑ, Ñ‡Ñ‚Ð¾ ÑÐ¾ÐµÐ´Ð¸Ð½ÐµÐ½Ð¸Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÐµÑ‚)
	_, err = io.CopyN(io.Discard, resp.Body, 4096)
	if err != nil && err != io.EOF {
		return CheckResult{
			Site:       site,
			Success:    false,
			StatusCode: resp.StatusCode,
			Error:      fmt.Sprintf("ÐžÑˆÐ¸Ð±ÐºÐ° Ñ‡Ñ‚ÐµÐ½Ð¸Ñ Ð¾Ñ‚Ð²ÐµÑ‚Ð°: %v", err),
			Duration:   time.Since(start),
		}
	}

	// ÐŸÑ€Ð¾Ð²ÐµÑ€ÑÐµÐ¼ ÑÑ‚Ð°Ñ‚ÑƒÑ ÐºÐ¾Ð´
	success := resp.StatusCode >= 200 && resp.StatusCode < 300
	
	if verbose {
		fmt.Printf("[DEBUG] %s: %d %s (%v)\n", 
			site.Name, resp.StatusCode, http.StatusText(resp.StatusCode), time.Since(start))
	}

	return CheckResult{
		Site:       site,
		Success:    success,
		StatusCode: resp.StatusCode,
		Error:      "",
		Duration:   time.Since(start),
	}
}

// ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° Ð²ÑÐµÑ… ÑÐ°Ð¹Ñ‚Ð¾Ð² Ñ Ð¾Ð³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð¸ÐµÐ¼ Ð½Ð° Ð¾Ð´Ð½Ð¾Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ðµ Ð·Ð°Ð¿Ñ€Ð¾ÑÑ‹
func checkAllSites(config *Config, verbose bool) []CheckResult {
	var wg sync.WaitGroup
	results := make([]CheckResult, len(config.Sites))
	semaphore := make(chan struct{}, config.General.ConcurrentChecks)

	for i, site := range config.Sites {
		wg.Add(1)
		go func(idx int, site SiteConfig) {
			defer wg.Done()
			
			// ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡Ð¸Ð²Ð°ÐµÐ¼ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð¾Ð´Ð½Ð¾Ð²Ñ€ÐµÐ¼ÐµÐ½Ð½Ñ‹Ñ… Ð·Ð°Ð¿Ñ€Ð¾ÑÐ¾Ð²
			semaphore <- struct{}{}
			defer func() { <-semaphore }()
			
			results[idx] = checkSite(site, verbose)
		}(i, site)
	}

	wg.Wait()
	return results
}

// Ð’Ñ‹Ð²Ð¾Ð´ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¾Ð²
func printResults(results []CheckResult, notifications Notifications) {
	if !notifications.ConsoleOutput {
		return
	}

	fmt.Println("\n" + strings.Repeat("=", 60))
	fmt.Println("Ð Ð•Ð—Ð£Ð›Ð¬Ð¢ÐÐ¢Ð« ÐŸÐ ÐžÐ’Ð•Ð ÐšÐ˜")
	fmt.Println(strings.Repeat("=", 60))

	allOK := true
	for _, result := range results {
		status := "âœ… OK"
		if !result.Success {
			status = "âŒ ERROR"
			allOK = false
		}
		
		errorMsg := ""
		if result.Error != "" {
			errorMsg = fmt.Sprintf(" | ÐžÑˆÐ¸Ð±ÐºÐ°: %s", result.Error)
		}
		
		fmt.Printf("%-20s %-10s [%d] %s (%v)%s\n",
			result.Site.Name,
			status,
			result.StatusCode,
			result.Site.URL,
			result.Duration.Round(time.Millisecond),
			errorMsg)
	}
	fmt.Println(strings.Repeat("=", 60))
	
	if allOK {
		fmt.Println("ðŸŽ‰ Ð’ÑÐµ ÑÐ°Ð¹Ñ‚Ñ‹ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚ Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ð¾!")
	} else {
		fmt.Println("âš ï¸ ÐžÐ±Ð½Ð°Ñ€ÑƒÐ¶ÐµÐ½Ñ‹ Ð¿Ñ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ñ Ð½ÐµÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¼Ð¸ ÑÐ°Ð¹Ñ‚Ð°Ð¼Ð¸")
	}
}

// ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ°, Ð²ÑÐµ Ð»Ð¸ ÑÐ°Ð¹Ñ‚Ñ‹ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚
func allSitesOK(results []CheckResult) bool {
	for _, result := range results {
		if !result.Success {
			return false
		}
	}
	return true
}

// ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Ð¾Ð± ÑƒÑÐ¿ÐµÑ…Ðµ
func sendSuccessNotification(config *Config) {
	if !config.Notifications.ShowPopup {
		return
	}

	// Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼ beeep Ð´Ð»Ñ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ð¹ Windows
	err := beeep.Notify(
		"Website Checker",
		"âœ… Ð’ÑÐµ ÑÐ°Ð¹Ñ‚Ñ‹ Ñ€Ð°Ð±Ð¾Ñ‚Ð°ÑŽÑ‚ Ð½Ð¾Ñ€Ð¼Ð°Ð»ÑŒÐ½Ð¾!",
		"assets/info.png", // ÐœÐ¾Ð¶Ð½Ð¾ Ð·Ð°Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ Ð½Ð° ÑÐ²Ð¾Ð¹ Ð¸ÐºÐ¾Ð½ÐºÑƒ
	)
	
	if err != nil {
		fmt.Printf("ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ: %v\n", err)
	}
}

// ÐžÑ‚Ð¿Ñ€Ð°Ð²ÐºÐ° ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ Ð¾Ð± Ð¾ÑˆÐ¸Ð±ÐºÐµ
func sendErrorNotification(config *Config, failedSites []string) {
	if !config.Notifications.ShowPopup {
		return
	}

	message := fmt.Sprintf("âš ï¸ ÐŸÑ€Ð¾Ð±Ð»ÐµÐ¼Ñ‹ Ñ ÑÐ°Ð¹Ñ‚Ð°Ð¼Ð¸:\n%s", strings.Join(failedSites, "\n"))
	
	err := beeep.Notify(
		"Website Checker - ÐžÑˆÐ¸Ð±ÐºÐ°!",
		message,
		"assets/warning.png",
	)
	
	if err != nil {
		fmt.Printf("ÐžÑˆÐ¸Ð±ÐºÐ° Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÐºÐ¸ ÑƒÐ²ÐµÐ´Ð¾Ð¼Ð»ÐµÐ½Ð¸Ñ: %v\n", err)
	}
}

// ÐÐµÐ¿Ñ€ÐµÑ€Ñ‹Ð²Ð½Ñ‹Ð¹ Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³
func runContinuousMonitoring(config *Config, verbose bool) {
	fmt.Println("Ð—Ð°Ð¿ÑƒÑÐº Ð½ÐµÐ¿Ñ€ÐµÑ€Ñ‹Ð²Ð½Ð¾Ð³Ð¾ Ð¼Ð¾Ð½Ð¸Ñ‚Ð¾Ñ€Ð¸Ð½Ð³Ð°...")
	fmt.Println("ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ Ctrl+C Ð´Ð»Ñ Ð¾ÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸")
	
	ticker := time.NewTicker(time.Duration(config.General.CheckInterval) * time.Second)
	defer ticker.Stop()
	
	// ÐŸÐµÑ€Ð²Ð°Ñ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÑ€Ð°Ð·Ñƒ
	results := checkAllSites(config, verbose)
	printResults(results, config.Notifications)
	
	if allSitesOK(results) {
		sendSuccessNotification(config)
	} else {
		failed := getFailedSites(results)
		sendErrorNotification(config, failed)
	}
	
	// ÐŸÐµÑ€Ð¸Ð¾Ð´Ð¸Ñ‡ÐµÑÐºÐ¸Ðµ Ð¿Ñ€Ð¾Ð²ÐµÑ€ÐºÐ¸
	for range ticker.C {
		fmt.Printf("\n[%s] ÐŸÑ€Ð¾Ð²ÐµÑ€ÐºÐ° ÑÐ°Ð¹Ñ‚Ð¾Ð²...\n", time.Now().Format("15:04:05"))
		
		results := checkAllSites(config, verbose)
		printResults(results, config.Notifications)
		
		if allSitesOK(results) {
			sendSuccessNotification(config)
		} else {
			failed := getFailedSites(results)
			sendErrorNotification(config, failed)
		}
	}
}

// ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ ÑÐ¿Ð¸ÑÐºÐ° ÑƒÐ¿Ð°Ð²ÑˆÐ¸Ñ… ÑÐ°Ð¹Ñ‚Ð¾Ð²
func getFailedSites(results []CheckResult) []string {
	var failed []string
	for _, result := range results {
		if !result.Success {
			failed = append(failed, fmt.Sprintf("%s (%s)", result.Site.Name, result.Site.URL))
		}
	}
	return failed
}

// Ð’ÑÐ¿Ð¾Ð¼Ð¾Ð³Ð°Ñ‚ÐµÐ»ÑŒÐ½Ð°Ñ Ñ„ÑƒÐ½ÐºÑ†Ð¸Ñ Ð´Ð»Ñ ÑÑ‚Ñ€Ð¾Ðº (Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð² Ð¸Ð¼Ð¿Ð¾Ñ€Ñ‚ "strings")